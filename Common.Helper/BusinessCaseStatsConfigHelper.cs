using AutoMapper;
using Common.Infrastructure.Data.Interfaces;
using Common.Infrastructure.Interfaces;
using Common.Infrastructure.Models;
using Microsoft.Extensions.Configuration;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;

// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using QuickType;
//
//    var businessCaseStatRuleConfigHelper = BusinessCaseStatRuleConfigHelper.FromJson(jsonString);
// Template code auto generated from https://app.quicktype.io/#l=cs&r=json2csharp

namespace Common.Helper
{
    public partial class BusinessCaseStatRuleConfigHelper : IConfigManager
    {
        public IMapper mapper;
        public IConfiguration configuration;
        RequestAndTaskLogStatTemplate requestAndTaskLogStatTemplate;

        // Cached config items
        Dictionary<string, ICommand[]> parsedCommands = new Dictionary<string, ICommand[]>();
        Dictionary<string, IAction[]> parsedActions = new Dictionary<string, IAction[]>();
        List<Tuple<List<string>, IRequestStatusTemplate>> requestStatusTemplateItems = new List<Tuple<List<string>, IRequestStatusTemplate>>();

        public BusinessCaseStatRuleConfigHelper(IMapper mapper, IConfiguration configuration)
        {
            this.mapper = mapper;
            this.configuration = configuration;
            var CurrentPath = AppDomain.CurrentDomain.BaseDirectory;
            var jsonBytes = File.ReadAllText(CurrentPath + "RequestAndTaskLogStatTemplate.json");
            requestAndTaskLogStatTemplate = RequestAndTaskLogStatTemplateRoot.FromJson(jsonBytes).RequestAndTaskLogStatTemplate;
        }

        public RequestAndTaskLogAction[] GetRequestAndTaskLogEventsActions(string eventName)
        {
            parsedActions.TryGetValue(eventName, out var actions);
            if (actions != null && actions.Length > 0) return (RequestAndTaskLogAction[])actions;
            var newActions = requestAndTaskLogStatTemplate.RequestAndTaskLogEvents.Find(item => item.Event == eventName)?.Actions;
            var mappedActions = mapper.Map<RequestAndTaskLogAction[]>(newActions);
            CollectionHelper.TryAdd(parsedActions, eventName, mappedActions);
            return (RequestAndTaskLogAction[])parsedActions[eventName];
        }

        public ICommand[] GetRequestAndTaskLogEventsOnProcessedCommands(string eventName)
        {
            parsedCommands.TryGetValue(eventName, out var commands);
            if (commands != null && commands.Length > 0) return commands;

            var commandsFromConfig = requestAndTaskLogStatTemplate.RequestAndTaskLogEvents.Find(item => item.Event == eventName)?.OnEventProcessed;
            List<ICommand> newCommands = new List<ICommand>();

            foreach (var command in commandsFromConfig)
            {
                var commandConfig = requestAndTaskLogStatTemplate.RequestAndTaskStatCommands.Find(item => item.Command == command);

                if (commandConfig == null || commandConfig.Actions == null || commandConfig.Actions.Count == 0)
                {
                    // Generic command may not have any actions in the config. So, just add one blank action for now.
                    var genericCommandsActions = new GenericCommandAction[] { new GenericCommandAction() };
                    var genericCommand = mapper.Map<GenericCommand>(command.ToString());
                    genericCommand.Actions = genericCommandsActions;
                    newCommands.Add(genericCommand);
                }
                else
                {
                    var requestAndTaskStatCommand = mapper.Map<Infrastructure.Models.RequestAndTaskStatCommand>(command.ToString());
                    var requestAndTaskStatCommandActions = new List<Infrastructure.Models.RequestAndTaskStatCommandAction>();
                    commandConfig.Actions.ForEach(action =>
                    {
                        var requestAndTaskStatCommandAction = mapper.Map<Infrastructure.Models.RequestAndTaskStatCommandAction>(action);
                        requestAndTaskStatCommandActions.Add(requestAndTaskStatCommandAction);
                    });
                    requestAndTaskStatCommand.Actions = requestAndTaskStatCommandActions.ToArray();
                    newCommands.Add(requestAndTaskStatCommand);
                }
            };
            CollectionHelper.TryAdd(parsedCommands, eventName, newCommands.ToArray());
            return parsedCommands[eventName];
        }

        public IRequestStatusTemplate[] GetRequestStatusTemplate(string[] taskNames)
        {
            var result = new List<Infrastructure.Models.RequestStatusTemplate>();
            foreach (var tuple in requestStatusTemplateItems)
            {
                var list = tuple.Item1;
                var statusTemplate = tuple.Item2;
                int foundTaskCount = 0;
                foreach (var task in taskNames)
                {
                    var taskFound = list.Find(item => item == task);
                    if (taskFound != null) foundTaskCount++;
                }

                if (foundTaskCount == taskNames.Count()) return new Infrastructure.Models.RequestStatusTemplate[] { (Infrastructure.Models.RequestStatusTemplate)statusTemplate };
                else if (foundTaskCount > 0) result.Add((Infrastructure.Models.RequestStatusTemplate)statusTemplate);
            }

            if (result.Count() > 0) return result.ToArray();

            var resultFromConfig = new List<Infrastructure.Models.RequestStatusTemplate>();
            foreach (var statusTemplateFromConfig in requestAndTaskLogStatTemplate.RequestStatusTemplate)
            {
                var expressionFromConfig = statusTemplateFromConfig.Expression;
                var taskNamesFromConfig = statusTemplateFromConfig.TaskName;
                int foundTaskCount = 0;
                foreach (var task in taskNames)
                {
                    var taskFound = taskNamesFromConfig.Find(item => item == task);
                    if (taskFound != null) foundTaskCount++;
                }
                var statusTemplateMapped = mapper.Map<Infrastructure.Models.RequestStatusTemplate>(statusTemplateFromConfig);
                requestStatusTemplateItems.Add(Tuple.Create(taskNamesFromConfig, (IRequestStatusTemplate)statusTemplateMapped));

                if (foundTaskCount == taskNames.Count())
                {
                    return new Infrastructure.Models.RequestStatusTemplate[] { statusTemplateMapped };
                }
                else if(foundTaskCount > 0)
                {
                    resultFromConfig.Add(statusTemplateMapped);
                }
            }
            return resultFromConfig.ToArray();
        }
    }

    public partial class RequestAndTaskLogStatTemplateRoot
    {
        [JsonProperty("RequestAndTaskLogStatTemplate")]
        public RequestAndTaskLogStatTemplate RequestAndTaskLogStatTemplate { get; set; }
    }

    public partial class RequestAndTaskLogStatTemplate
    {
        [JsonProperty("BlacklistUsersForTaskAssignment")]
        public List<string> BlacklistUsersForTaskAssignment { get; set; }

        [JsonProperty("RequestAndTaskLogEvents")]
        public List<RequestAndTaskLogEvent> RequestAndTaskLogEvents { get; set; }

        [JsonProperty("RequestAndTaskStatCommands")]
        public List<RequestAndTaskStatCommand> RequestAndTaskStatCommands { get; set; }

        [JsonProperty("RequestStatusTemplate")]
        public List<RequestStatusTemplate> RequestStatusTemplate { get; set; }
    }

    public partial class RequestAndTaskLogEvent
    {
        [JsonProperty("Event")]
        public string Event { get; set; }

        [JsonProperty("Actions")]
        public List<RequestAndTaskLogEventAction> Actions { get; set; }

        [JsonProperty("OnEventProcessed")]
        public List<Command> OnEventProcessed { get; set; }
    }

    public partial class RequestAndTaskLogEventAction
    {
        [JsonProperty("Name")]
        public string Name { get; set; }

        [JsonProperty("Expression")]
        public string Expression { get; set; }
    }

    public partial class RequestAndTaskStatCommand
    {
        [JsonProperty("Command")]
        public Command Command { get; set; }

        [JsonProperty("Actions")]
        public List<RequestAndTaskStatCommandAction> Actions { get; set; }
    }

    public partial class RequestAndTaskStatCommandAction
    {
        [JsonProperty("Name")]
        public string Name { get; set; }

        [JsonProperty("Expression")]
        public List<Expression> Expression { get; set; }
    }

    public partial class Expression
    {
        [JsonProperty("Criteria", NullValueHandling = NullValueHandling.Ignore)]
        public string Criteria { get; set; }

        [JsonProperty("Expression", NullValueHandling = NullValueHandling.Ignore)]
        public string TargetExpression { get; set; }

        [JsonProperty("ConditionPipe", NullValueHandling = NullValueHandling.Ignore)]
        public string ConditionPipe { get; set; }
    }

    public partial class RequestStatusTemplate
    {
        [JsonProperty("TaskName")]
        public List<string> TaskName { get; set; }

        [JsonProperty("PercentageComplete")]
        [JsonConverter(typeof(ParseStringConverter))]
        public long PercentageComplete { get; set; }

        [JsonProperty("Expression")]
        public List<RequestStatusTemplateExpression> Expression { get; set; }
    }

    public partial class RequestStatusTemplateExpression
    {
        [JsonProperty("Expression")]
        public string Expression { get; set; }

        [JsonProperty("Criteria")]
        public string Criteria { get; set; }
    }

    public enum Command { CalculateRequestApprovalStatus, CalculateRequestOneLineSummary, CalculateRequestPercentageComplete, CalculateTaskOneLineSummaryForAllTasks, CalculateTimeElapseForCollectATCAmount, CalculateTimeElapseForCollectFinanceData, CalculateTimeElapseForExecutivesAndCFOReview, CancelTasksIfAny, CompleteTasksIfAny };

    public partial class RequestAndTaskLogStatTemplateRoot
    {
        public static RequestAndTaskLogStatTemplateRoot FromJson(string json) => JsonConvert.DeserializeObject<RequestAndTaskLogStatTemplateRoot>(json, Converter.Settings);
    }

    public static class Serialize
    {
        public static string ToJson(this RequestAndTaskLogStatTemplateRoot self) => JsonConvert.SerializeObject(self, Converter.Settings);
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                CommandConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class CommandConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Command) || t == typeof(Command?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "CalculateRequestApprovalStatus":
                    return Command.CalculateRequestApprovalStatus;
                case "CalculateRequestOneLineSummary":
                    return Command.CalculateRequestOneLineSummary;
                case "CalculateRequestPercentageComplete":
                    return Command.CalculateRequestPercentageComplete;
                case "CalculateTaskOneLineSummaryForAllTasks":
                    return Command.CalculateTaskOneLineSummaryForAllTasks;
                case "CalculateTimeElapseForCollectATCAmount":
                    return Command.CalculateTimeElapseForCollectATCAmount;
                case "CalculateTimeElapseForExecutivesAndCFOReview":
                    return Command.CalculateTimeElapseForExecutivesAndCFOReview;
                case "CalculateTimeElapseForCollectFinanceData":
                    return Command.CalculateTimeElapseForCollectFinanceData;
                case "CancelTasksIfAny":
                    return Command.CancelTasksIfAny;
                case "CompleteTasksIfAny":
                    return Command.CompleteTasksIfAny;
            }
            throw new Exception("Cannot unmarshal type Command");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (Command)untypedValue;
            switch (value)
            {
                case Command.CalculateRequestApprovalStatus:
                    serializer.Serialize(writer, "CalculateRequestApprovalStatus");
                    return;
                case Command.CalculateRequestOneLineSummary:
                    serializer.Serialize(writer, "CalculateRequestOneLineSummary");
                    return;
                case Command.CalculateRequestPercentageComplete:
                    serializer.Serialize(writer, "CalculateRequestPercentageComplete");
                    return;
                case Command.CalculateTaskOneLineSummaryForAllTasks:
                    serializer.Serialize(writer, "CalculateTaskOneLineSummaryForAllTasks");
                    return;
                case Command.CalculateTimeElapseForCollectATCAmount:
                    serializer.Serialize(writer, "CalculateTimeElapseForCollectATCAmount");
                    return;
                case Command.CalculateTimeElapseForCollectFinanceData:
                    serializer.Serialize(writer, "CalculateTimeElapseForCollectFinanceData");
                    return;
                case Command.CancelTasksIfAny:
                    serializer.Serialize(writer, "CancelTasksIfAny");
                    return;
            }
            throw new Exception("Cannot marshal type Command");
        }

        public static readonly CommandConverter Singleton = new CommandConverter();
    }

    internal class ParseStringConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(long) || t == typeof(long?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            long l;
            if (Int64.TryParse(value, out l))
            {
                return l;
            }
            throw new Exception("Cannot unmarshal type long");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (long)untypedValue;
            serializer.Serialize(writer, value.ToString());
            return;
        }

        public static readonly ParseStringConverter Singleton = new ParseStringConverter();
    }
}

